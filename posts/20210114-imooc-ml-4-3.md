# 4-3 划分训练数据集、测试数据集

判断机器学习算法的性能？

训练得到的模型直接在真实环境中使用。

问题：

- 模型很差怎么办？真实损失
- 真实环境难以拿到真实的 label

通过测试数据直接判断模型好坏，在模型进入真实环境前改进模型。

train test split

# 测试我们的算法


```python
import numpy as np
import  matplotlib.pyplot as plt
from sklearn import datasets
```


```python
iris = datasets.load_iris()
```


```python
X = iris.data
y = iris.target
```


```python
X.shape
```




    (150, 4)




```python
y.shape
```




    (150,)



### 编写自己的 train_test_split 划分测试集和训练集


```python
# y 是有序的
y
```




    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])




```python
# 需要进行打乱 shuffle
# X 和 y 是一一对应的
# 方法 1：X和y合并再打乱，最后在划分
# 方法 2：
shuffle_indexes = np.random.permutation(len(X))
# [0, 150) 的随机排列
shuffle_indexes
```




    array([135, 128, 107,  21, 119,  12, 122,  62,   6,   0, 143,  76,  27,
            87, 103,  26,  95, 124,  97, 100,  19,  91,  35,  80,   8,  82,
           140,  88, 114, 104,  42, 145, 105,   1,  58,  96,  92,  85, 118,
           127,  65,  57,  72, 117,  77, 108,  52, 109, 139, 148,  68,  11,
             2, 121,  70, 112,  37,  28, 113,  51,  53, 116,  74, 102, 115,
           133,  16,  63, 138, 144,  94,  83,  98,  20,   4,  13,  33,  29,
            46,  60, 130, 136,  18,  15,  89,  31, 132,  93, 111,  32,  86,
            69,  45,  67,  84,  17,   3,  66,   7,  56,  44,  38,  36,  43,
            79, 146, 141, 142,   9,  71, 123,  23, 137, 129,  47, 101, 149,
            30,   5,  50, 125,  41,  10, 126,  34,  55,  48, 120, 110,  14,
            61,  22,  49,  24,  64, 106,  39,  54,  99,  25, 147,  73, 131,
            75,  59,  78, 134,  40,  81,  90])




```python
test_ratio = 0.2
test_size = int(len(X) * test_ratio)
```


```python
# 30 和测试集
test_size
```




    30




```python
test_indexes = shuffle_indexes[:test_size]
train_indexes = shuffle_indexes[test_size:]
```


```python
# Fancy Indexing
X_train = X[train_indexes]
y_train = y[train_indexes]

X_test = X[test_indexes]
y_test = y[test_indexes]
```


```python
print(X_train.shape)
print(y_train.shape)
```

    (120, 4)
    (120,)


### 封装成函数

```python
import numpy as np

def train_test_split(X, y, test_ratio=0.2, seed=None):
    """将数据 X 和 y 安装 test_ratio 分割成 X_train, X_test, y_train, y_test"""

    assert X.shape[0] == y.shape[0], \
        "the size of X must be equal to the size of y"
    assert 0.0 <= test_ratio <= 1.0, \
        "test_ratio must be valid"
    
    # 方便调试 debug
    if seed:
        np.random.seed(seed)
    
    # [0, 150) 的随机排列
    shuffle_indexes = np.random.permutation(len(X))
    
    test_size = int(len(X) * test_ratio)
    test_indexes = shuffle_indexes[:test_size]
    train_indexes = shuffle_indexes[test_size:]
    
    X_train = X[train_indexes]
    y_train = y[train_indexes]

    X_test = X[test_indexes]
    y_test = y[test_indexes]
    
    return X_train, X_test, y_train, y_test
```


```python
# 自己编写封装的 train_test_split
from playML.model_selection import train_test_split
```


```python
X_train, X_test, y_train, y_test = train_test_split(X, y)
```


```python
# 训练集
print(X_train.shape)
print(y_train.shape)
```

    (120, 4)
    (120,)



```python
# 测试集
print(X_test.shape)
print(y_test.shape)
```

    (30, 4)
    (30,)



```python
# 4-2 自己编写的KNNClassifier
from playML.kNN import KNNClassifier
```


```python
my_knn_clf = KNNClassifier(k=3)
```


```python
my_knn_clf.fit(X_train, y_train)
```




    <playML.kNN.KNNClassifier at 0x7f90ac1054e0>




```python
y_predict = my_knn_clf.predict(X_test)
```


```python
y_predict
```




    array([0, 2, 1, 2, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 2, 1, 1, 2, 1, 2,
           2, 1, 1, 2, 2, 1, 2, 0])




```python
y_test
```




    array([0, 2, 1, 2, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 2, 1, 2, 2, 1, 2,
           2, 1, 1, 2, 2, 1, 2, 0])




```python
# y_predict 和 y_test 进行比较，得到准确率

# 29 个相同
sum(y_predict == y_test)
```




    29




```python
# 准确率 96.7 %
sum(y_predict == y_test) / len(y_test)
```




    0.9666666666666667



## sklearn 中的 train_test_split


```python
# 自己编写接口设置与sklearn保持一致
from sklearn.model_selection import train_test_split
```


```python
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
```


```python
# 训练集
print(X_train.shape)
print(y_train.shape)
```

    (120, 4)
    (120,)



```python
# 测试集
print(X_test.shape)
print(y_test.shape)
```

    (30, 4)
    (30,)


