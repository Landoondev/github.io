[1672. 最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)

就是数组求和。

```c++
class Solution {
public:
    int maximumWealth(vector<vector<int>>& accounts) {
      int val = 0;
      for (int i = 0; i < accounts.size(); ++i) {
        val = max(val, accumulate(accounts[i].begin(), accounts[i].end(), 0));
      }
      return val;
    }
};
```

没什么难的。

[1678. 设计 Goal 解析器](https://leetcode-cn.com/problems/goal-parser-interpretation/)

不考虑非法输入的情况，写的丑陋了些。

```c++
class Solution {
public:
    string interpret(string command) {
      string res;
      for (int i = 0; i < command.size(); ++i) {
        if (command[i] == '(' && i + 1 < command.size() &&  command[i+1] == ')')
          res.push_back('o');
        if (command[i] == '(' || command[i] == ')')
          continue;
        res.push_back(command[i]);  
      }
      return res;
    }
};
```

还有没有更加优雅的实现呢？

[1108. IP 地址无效化](https://leetcode-cn.com/problems/defanging-an-ip-address/)

```c++
class Solution {
public:
    string defangIPaddr(string address) {
      string s = "";
      for (int i = 0; i < address.size(); ++i) {
        if (address[i] == '.')
          s += "[.]";
        else
          s += address[i];
      }
      return s;
    }
};
```

[LCP 06. 拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)

这题让我想起了动态规划的爬楼梯问题。

```c++
class Solution {
 private:
  int min_count(int n) {
    if (n == 0 || n == 1) {
      return n;
    }
    if (n == 2) 
      return 1;
    
    return min(min_count(n - 1), min_count(n - 2)) + 1;
  }
public:
    int minCount(vector<int>& coins) {
      int count = 0;
      for (int i = 0; i < coins.size(); i++) {
        count += min_count(coins[i]);
      }
      return count;
    }
};
```

[1389. 按既定顺序创建目标数组](https://leetcode-cn.com/problems/create-target-array-in-the-given-order/)

```c++
class Solution {
public:
    vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {
      assert(nums.size() == index.size());
      vector<int> target;
      for (int i = 0; i < nums.size(); ++i) {
        target.insert(target.begin() + index[i], nums[i]);
      }
      return target;
    }
};
```

