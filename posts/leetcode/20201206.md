[893. 特殊等价字符串组](https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/)

思考：

将偶数和奇数索引单独分别排序，统计排序后相同的字符串。

如何实现偶数索引排序？

排序+一一比较的成本很高。还有什么好的方法吗？

排序似乎是不行的，因为要一对一对的。

```shell
输入：["abc","acb","bac","bca","cab","cba"]
输出：3
解释：3 组 ["abc","cba"]，["acb","bca"]，["bac","cab"]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/groups-of-special-equivalent-strings
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

顺序没乱。

---

解：

- 思路：等价字符串就是偶数位(奇数位) 的字符每个字母一样多

使用 Set 求解？不是用 Set 怎么求？

## 使用 Set

使用 STL

```c++
class Solution {
public:
    int numSpecialEquivGroups(vector<string>& A) {
      unordered_set<string>  record;
      for (const auto &str : A) {
        string odd = "", even = "";
        for (int i = 0; i < str.size(); ++i) {
          if (i % 2 == 0)
            even.push_back(str[i]);
          else
            odd.push_back(str[i]);
        }
        sort(odd.begin(), odd.end());
        sort(even.begin(), even.end());
        record.insert(odd + even);
      }
      return record.size();
    }
};
```

## 不给使用 C++ 任何 STL 函数

面试时可能会考这样的问题，如果不能使用 STL，那么就需要更换解题思路了。

。。。

---

我发现一个难度升级的问题，请看如下输入：

```c++
["abcd","cdab","cbad"]
```

正确的结果应该是 2。`abcd` 和 `cdab` 是一对，`abcd` 和 `cbad` 也是一对。`abcd` 重复用了两次。

 把对应的组也输出，这也是一道拓展的难题。

## 其他

我觉得位操作真的很有用，能写出高效且非常惊艳的代码。

明天以位运算（二进制）为主题，写一篇数学史的文章。

