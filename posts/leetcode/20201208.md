[1431. 拥有最多糖果的孩子](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)

题目很好理解，关键是怎么写出高效率的程序。

先找出拥有糖果最多的。

```c++
class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
      int max_value = 0;
      vector<bool> res(candies.size());
      for (int i = 0; i < candies.size(); ++i) {
        if (candies[i] > max_value) {
          max_value = candies[i];
        }
      }
      for (int i = 0; i < candies.size(); ++i) {
        res[i] = candies[i] < max_value - extraCandies ? false : true;
      }
      return res;
    }
};
```

[1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)

有一种定义法的感觉，直接根据定义写出算法。

```c++
class Solution {
public:
    int xorOperation(int n, int start) {
      int v = 0;
      for (int i = 0; i < n; ++i) {
        v ^= (start + 2*i);
      }
      return v;
    }
};
```

[1603. 设计停车系统](https://leetcode-cn.com/problems/design-parking-system/)

考察的数组的索引。

```c++
class ParkingSystem {
public:
    ParkingSystem(int big, int medium, int small) {
      type[1] = big;
      type[2] = medium;
      type[3] = small;
    }
    
    bool addCar(int carType) {
      if (type[carType] > 0) {
        type[carType]--;
        return true;
      }
      return false;
    }
 private:
  int type[4];
};

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem* obj = new ParkingSystem(big, medium, small);
 * bool param_1 = obj->addCar(carType);
 */
```

[1662. 检查两个字符串数组是否相等](https://leetcode-cn.com/problems/check-if-two-string-arrays-are-equivalent/)

先分别加起来，然后比较肯定非常慢。

```c++
class Solution {
public:
    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {
      string a = "", b = "";
      for (const string & str : word1)
        a += str;
      for (const string & str : word2)
        b += str;
      
      return a == b;
    }
};
```

能不能一边遍历一边比较，如果第一个字符就不一样，就可以非常快的结束。算法的效率也会非常高。

细细想想这个算法非常有意思，有很多循环，逻辑容易混乱。

```c++
class Solution {
public:
    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {
      int i1 = 0, j1 = 0, i2 = 0, j2 = 0;
      while (i1 < word1.size() && i2 < word2.size()) {
        if (word1[i1][j1] != word2[i2][j2])
          return false;
        else { // ==
          if (j1 + 1 >= word1[i1].size()) {
            j1 = 0;
            i1++;
          }
          else
            j1++;
          
          if (j2 + 1 >= word2[i2].size()) {
            j2 = 0;
            i2++;
          }
          else
            j2++;
        }
      }
      return i1 == word1.size() && i2 == word2.size();
    }
};
```



















