[1460. 通过翻转子数组使两个数组相等](https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/)

我在想，可以排序吗？非空的子数组。可以，但是这绝对不是一个好方法。

```c++
class Solution {
public:
    bool canBeEqual(vector<int>& target, vector<int>& arr) {
      sort(target.begin(), target.end());
      sort(arr.begin(), arr.end());

      return target == arr;
    }
};
```

我觉得 target 没必要改变，算法还有很大的优化空间。

进行词频统计。

```c++
class Solution {
public:
    bool canBeEqual(vector<int>& target, vector<int>& arr) {
      if (target.size() != arr.size()) {
        return false;
      }

      int req[1001] = {0};
      for (int i = 0; i < target.size(); ++i) {
        req[target[i]]++;
        req[arr[i]]--;
      }

      for (int i = 0; i < 1001; ++i) {
        if (req[i] != 0)
          return false;
      }

      return true;
    }
};
```

[1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

很简单。我认为完全可以在原数组上进行修改。

```c++
class Solution {
public:
    vector<int> runningSum(vector<int>& nums) {
      for (int i = 1; i < nums.size(); ++i)
        nums[i] = nums[i-1] + nums[i];
      return nums;
    }
};
```

[1512. 好数对的数目](https://leetcode-cn.com/problems/number-of-good-pairs/)

$O(n^2)$ 的算法，冒泡排序的思想。

```c++
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
      int n = 0;
      for (int i = 0; i < nums.size(); ++i) {
        for (int j  = i+1; j < nums.size(); ++j) {
          if (nums[j] == nums[i])
            n++;
        }
      }
      return n;
    }
};
```

使用 Hash Map 进行频率统计，如果数组 x 出现的频率是 n，那么它对应的好数对位 $\frac{n(n-1)}{2}$。

```c++
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
      unordered_map<int, int> req;
      for (int i = 0; i < nums.size(); ++i) {
        req[nums[i]]++;
      }
      int res = 0;
      for (const auto [k, v] : req) {
        res += (v * (v - 1)) / 2; 
      }
      return res;
    }
};
```

这里可以学到一个遍历 Hash Map 的方法。

 [1470. 重新排列数组 ](https://leetcode-cn.com/problems/shuffle-the-array/)⭐️刘宇波老师写了题解

这个题目让我想起了一个原地交换内存的算法，在编程珠玑里面看到的。

数组：`1, 2, 3, 4, 5, 6, 7, 8, 9, 10`

- `1, 2, 3, 4, 5` `6, 7, 8, 9, 10`
- `5, 4, 3, 2, 1` `10, 9, 8, 7, 6`
- `6, 7, 8, 9, 10, 1, 2, 3, 4, 5`

```c++
reverse(0, s-1);  // 左边部分
reverse(s, n-1);  // 右边部分
reverse(0, n-1);  // 整体
```

空间复杂度为 $O(n)$ 的很简单，就不实现了。

但是空间复杂度要求 $O(1)$ 这题真有意思，想了很久....

刘宇波老师的代码。

```c++
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++){
            int j = i < n ? 2 * i : 2 * (i - n) + 1;
            nums[j] |= (nums[i] & 1023) << 10;
        }
        for(int& e: nums) e >>= 10;
        return nums;
    }
};

```



