# 20201204

 [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
> 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```


示例 2：

```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

---

**解题思路：**

传入的是一个字符数组，使用两个索引：`i` 和 `j`。

- `i` ：指向数组的第一个元素；
- `j` ：指向数组的最后一个元素。

如果 `i < j` 则 `swap(array[i++], array[j--])`。一直重复循环下去。

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int i = 0, j = s.size()-1;
        while (i < j) {
          swap(s[i++], s[j--]);
        }
    }
};
```

[1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)

**解题思路：**

1. 不需要进行非法检测，输入保证的合法的，只需要完成题目要求即可。
2. 只要保证 `s[i] != s[i-1]` 和 `s[i] != s[i+1]` 即可。

注意检查索引的合法性：`i - 1>=0` 、`i + 1 < s.size()`

```c
class Solution {
public:
    string modifyString(string s) {
      int n = s.size();
      for (int i = 0; i < n; i++) {
        if (s[i] == '?') {
          char a = 'a';
          while ((i > 0 && s[i - 1] == a) || (i < n - 1 && s[i+1] == a))
            a++;
          s[i] = a;
        }
      }
      return s;
    }
};
```



